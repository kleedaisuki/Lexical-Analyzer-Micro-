+ OPERATOR    >> #
@ LABEL       >> ifndef
@ LABEL       >> _LIST_HEADER
+ OPERATOR    >> #
@ LABEL       >> define
@ LABEL       >> _LIST_HEADER
@ LABEL       >> template
+ OPERATOR    >> <
@ LABEL       >> typename
@ LABEL       >> Any
+ OPERATOR    >> >
@ LABEL       >> class
@ LABEL       >> List
+ OPERATOR    >> {
@ LABEL       >> private
+ OPERATOR    >> :
@ LABEL       >> struct
@ LABEL       >> unit
+ OPERATOR    >> {
@ LABEL       >> unit
+ OPERATOR    >> *
@ LABEL       >> before
+ OPERATOR    >> ,
+ OPERATOR    >> *
@ LABEL       >> next
+ OPERATOR    >> ;
@ LABEL       >> Any
@ LABEL       >> object
+ OPERATOR    >> ;
@ LABEL       >> unit
+ OPERATOR    >> (
* KEYWORD     >> void
+ OPERATOR    >> )
+ OPERATOR    >> :
@ LABEL       >> object
+ OPERATOR    >> (
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> before
+ OPERATOR    >> =
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> nullptr
+ OPERATOR    >> ;
+ OPERATOR    >> }
+ OPERATOR    >> }
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> A
@ LABEL       >> more
@ LABEL       >> complex
* KEYWORD     >> and
@ LABEL       >> comsuming
@ LABEL       >> basic
@ LABEL       >> structure
+ OPERATOR    >> .
& INSTRUCTION >> //
@ LABEL       >> Provide
@ LABEL       >> a
@ LABEL       >> much
@ LABEL       >> better
@ LABEL       >> support
@ LABEL       >> to
@ LABEL       >> insert
* KEYWORD     >> and
@ LABEL       >> pop
+ OPERATOR    >> .
& INSTRUCTION >> //
@ LABEL       >> Support
@ LABEL       >> more
@ LABEL       >> powerful
@ LABEL       >> iterator
+ OPERATOR    >> .
@ LABEL       >> public
+ OPERATOR    >> :
@ LABEL       >> class
@ LABEL       >> Iterator
& INSTRUCTION >> //
@ LABEL       >> Powerful
@ LABEL       >> enough
@ LABEL       >> to
@ LABEL       >> be
@ LABEL       >> treat
@ LABEL       >> as
@ LABEL       >> pointers
+ OPERATOR    >> .
+ OPERATOR    >> {
@ LABEL       >> private
+ OPERATOR    >> :
@ LABEL       >> friend
@ LABEL       >> List
+ OPERATOR    >> ;
@ LABEL       >> unit
+ OPERATOR    >> *
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> protected
+ OPERATOR    >> :
@ LABEL       >> public
+ OPERATOR    >> :
* KEYWORD     >> inline
@ LABEL       >> Iterator
+ OPERATOR    >> (
* KEYWORD     >> void
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> nullptr
+ OPERATOR    >> ;
+ OPERATOR    >> }
* KEYWORD     >> inline
@ LABEL       >> Iterator
+ OPERATOR    >> (
* KEYWORD     >> const
@ LABEL       >> Iterator
+ OPERATOR    >> &
@ LABEL       >> other
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> other
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
+ OPERATOR    >> }
* KEYWORD     >> inline
@ LABEL       >> Iterator
+ OPERATOR    >> &
@ LABEL       >> operator
+ OPERATOR    >> ++
+ OPERATOR    >> (
* KEYWORD     >> void
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> ;
* KEYWORD     >> return
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> ;
+ OPERATOR    >> }
* KEYWORD     >> inline
@ LABEL       >> Iterator
+ OPERATOR    >> &
@ LABEL       >> operator
+ OPERATOR    >> ++
+ OPERATOR    >> (
* KEYWORD     >> int
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> return
+ OPERATOR    >> ++
+ OPERATOR    >> (
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> )
+ OPERATOR    >> ;
+ OPERATOR    >> }
* KEYWORD     >> inline
@ LABEL       >> Iterator
+ OPERATOR    >> &
@ LABEL       >> operator
+ OPERATOR    >> --
+ OPERATOR    >> (
* KEYWORD     >> void
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> ;
* KEYWORD     >> return
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> ;
+ OPERATOR    >> }
* KEYWORD     >> inline
@ LABEL       >> Any
+ OPERATOR    >> &
@ LABEL       >> operator
+ OPERATOR    >> *
+ OPERATOR    >> (
* KEYWORD     >> void
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> return
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> object
+ OPERATOR    >> ;
+ OPERATOR    >> }
* KEYWORD     >> inline
@ LABEL       >> Iterator
+ OPERATOR    >> &
@ LABEL       >> operator
+ OPERATOR    >> --
+ OPERATOR    >> (
* KEYWORD     >> int
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> return
+ OPERATOR    >> --
+ OPERATOR    >> (
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> )
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> Iterator
@ LABEL       >> operator
+ OPERATOR    >> +
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> offset
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> Iterator
+ OPERATOR    >> &
@ LABEL       >> operator
+ OPERATOR    >> +=
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> offset
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> Iterator
@ LABEL       >> operator
+ OPERATOR    >> -
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> offset
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> Iterator
+ OPERATOR    >> &
@ LABEL       >> operator
+ OPERATOR    >> -=
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> offset
+ OPERATOR    >> )
+ OPERATOR    >> ;
* KEYWORD     >> inline
@ LABEL       >> Any
+ OPERATOR    >> &
@ LABEL       >> operator
+ OPERATOR    >> [
+ OPERATOR    >> ]
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> offset
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> Iterator
@ LABEL       >> iter
+ OPERATOR    >> (
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> )
+ OPERATOR    >> ;
* KEYWORD     >> return
+ OPERATOR    >> *
+ OPERATOR    >> (
@ LABEL       >> iter
+ OPERATOR    >> +
@ LABEL       >> offset
+ OPERATOR    >> )
+ OPERATOR    >> ;
+ OPERATOR    >> }
* KEYWORD     >> inline
@ LABEL       >> operator
@ LABEL       >> Any
+ OPERATOR    >> *
+ OPERATOR    >> (
* KEYWORD     >> void
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> return
+ OPERATOR    >> &
+ OPERATOR    >> (
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> object
+ OPERATOR    >> )
+ OPERATOR    >> ;
+ OPERATOR    >> }
& INSTRUCTION >> //
@ LABEL       >> Behavior
@ LABEL       >> like
@ LABEL       >> a
@ LABEL       >> pointer
+ OPERATOR    >> .
+ OPERATOR    >> }
+ OPERATOR    >> ;
@ LABEL       >> private
+ OPERATOR    >> :
@ LABEL       >> size_t
@ LABEL       >> element_count
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> The
@ LABEL       >> counter
@ LABEL       >> for
@ LABEL       >> element
@ LABEL       >> amount
+ OPERATOR    >> .
@ LABEL       >> Iterator
@ LABEL       >> start
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> An
@ LABEL       >> iterator
@ LABEL       >> that
@ LABEL       >> points
@ LABEL       >> to
@ LABEL       >> the
@ LABEL       >> first
@ LABEL       >> element
+ OPERATOR    >> .
@ LABEL       >> Iterator
@ LABEL       >> end
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> An
@ LABEL       >> iterator
@ LABEL       >> that
@ LABEL       >> points
@ LABEL       >> to
@ LABEL       >> the
@ LABEL       >> last
@ LABEL       >> element
+ OPERATOR    >> .
@ LABEL       >> protected
+ OPERATOR    >> :
& INSTRUCTION >> /*
@ LABEL       >> The
@ LABEL       >> following
@ LABEL       >> functions
@ LABEL       >> are
@ LABEL       >> inner
@ LABEL       >> member
@ LABEL       >> functions
@ LABEL       >> that
@ LABEL       >> realize
@ LABEL       >> public
@ LABEL       >> member
@ LABEL       >> function
^ CHAR        >> `
@ LABEL       >> append
^ CHAR        >> `
@ LABEL       >> below
+ OPERATOR    >> .
@ LABEL       >> Expand
@ LABEL       >> template
@ LABEL       >> parameter
@ LABEL       >> package
@ LABEL       >> recursively
+ OPERATOR    >> .
& INSTRUCTION >> */
+ OPERATOR    >> */
@ LABEL       >> template
+ OPERATOR    >> <
@ LABEL       >> typename
+ OPERATOR    >> .
+ OPERATOR    >> .
+ OPERATOR    >> .
@ LABEL       >> Args
+ OPERATOR    >> >
* KEYWORD     >> void
@ LABEL       >> _append
+ OPERATOR    >> (
@ LABEL       >> Any
+ OPERATOR    >> &
@ LABEL       >> first_element
+ OPERATOR    >> ,
@ LABEL       >> Args
+ OPERATOR    >> .
+ OPERATOR    >> .
+ OPERATOR    >> .
@ LABEL       >> parameters
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> append
+ OPERATOR    >> (
@ LABEL       >> first_element
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> _append
+ OPERATOR    >> (
@ LABEL       >> forward
+ OPERATOR    >> <
@ LABEL       >> Args
+ OPERATOR    >> >
+ OPERATOR    >> (
@ LABEL       >> parameters
+ OPERATOR    >> )
+ OPERATOR    >> .
+ OPERATOR    >> .
+ OPERATOR    >> .
+ OPERATOR    >> )
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Recursive
@ LABEL       >> call
+ OPERATOR    >> .
+ OPERATOR    >> }
@ LABEL       >> template
+ OPERATOR    >> <
@ LABEL       >> typename
+ OPERATOR    >> .
+ OPERATOR    >> .
+ OPERATOR    >> .
@ LABEL       >> Args
+ OPERATOR    >> >
* KEYWORD     >> void
@ LABEL       >> _append
+ OPERATOR    >> (
@ LABEL       >> Any
+ OPERATOR    >> &&
@ LABEL       >> first_element
+ OPERATOR    >> ,
@ LABEL       >> Args
+ OPERATOR    >> .
+ OPERATOR    >> .
+ OPERATOR    >> .
@ LABEL       >> parameters
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> append
+ OPERATOR    >> (
@ LABEL       >> forward
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> (
@ LABEL       >> first_element
+ OPERATOR    >> )
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> _append
+ OPERATOR    >> (
@ LABEL       >> forward
+ OPERATOR    >> <
@ LABEL       >> Args
+ OPERATOR    >> >
+ OPERATOR    >> (
@ LABEL       >> parameters
+ OPERATOR    >> )
+ OPERATOR    >> .
+ OPERATOR    >> .
+ OPERATOR    >> .
+ OPERATOR    >> )
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Recursive
@ LABEL       >> call
+ OPERATOR    >> .
+ OPERATOR    >> }
@ LABEL       >> template
+ OPERATOR    >> <
@ LABEL       >> typename
+ OPERATOR    >> .
+ OPERATOR    >> .
+ OPERATOR    >> .
@ LABEL       >> Args
+ OPERATOR    >> >
* KEYWORD     >> void
@ LABEL       >> _append
+ OPERATOR    >> (
@ LABEL       >> Any
+ OPERATOR    >> *
@ LABEL       >> first_element
+ OPERATOR    >> ,
@ LABEL       >> Args
+ OPERATOR    >> .
+ OPERATOR    >> .
+ OPERATOR    >> .
@ LABEL       >> parameters
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> append
+ OPERATOR    >> (
+ OPERATOR    >> *
@ LABEL       >> first_element
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> _append
+ OPERATOR    >> (
@ LABEL       >> forward
+ OPERATOR    >> <
@ LABEL       >> Args
+ OPERATOR    >> >
+ OPERATOR    >> (
@ LABEL       >> parameters
+ OPERATOR    >> )
+ OPERATOR    >> .
+ OPERATOR    >> .
+ OPERATOR    >> .
+ OPERATOR    >> )
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Recursive
@ LABEL       >> call
+ OPERATOR    >> .
+ OPERATOR    >> }
& INSTRUCTION >> //
@ LABEL       >> Support
@ LABEL       >> passing
@ LABEL       >> a
@ LABEL       >> pointer
+ OPERATOR    >> .
* KEYWORD     >> inline
* KEYWORD     >> void
@ LABEL       >> _append
+ OPERATOR    >> (
* KEYWORD     >> void
+ OPERATOR    >> )
+ OPERATOR    >> {
+ OPERATOR    >> }
& INSTRUCTION >> //
@ LABEL       >> For
@ LABEL       >> a
@ LABEL       >> more
@ LABEL       >> robust
@ LABEL       >> program
+ OPERATOR    >> ,
@ LABEL       >> set
@ LABEL       >> the
@ LABEL       >> end
@ LABEL       >> of
@ LABEL       >> the
@ LABEL       >> recursion
+ OPERATOR    >> .
* KEYWORD     >> void
@ LABEL       >> release
+ OPERATOR    >> (
* KEYWORD     >> void
+ OPERATOR    >> )
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Deconstructor
+ OPERATOR    >> .
@ LABEL       >> public
+ OPERATOR    >> :
* KEYWORD     >> inline
@ LABEL       >> List
+ OPERATOR    >> (
* KEYWORD     >> void
+ OPERATOR    >> )
+ OPERATOR    >> :
@ LABEL       >> start
+ OPERATOR    >> (
+ OPERATOR    >> )
+ OPERATOR    >> ,
@ LABEL       >> end
+ OPERATOR    >> (
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> element_count
+ OPERATOR    >> =
$ NUMBER      >> 0
+ OPERATOR    >> ;
+ OPERATOR    >> }
& INSTRUCTION >> //
@ LABEL       >> Default
@ LABEL       >> constructor
@ LABEL       >> without
@ LABEL       >> parameters
@ LABEL       >> for
@ LABEL       >> List
+ OPERATOR    >> .
& INSTRUCTION >> /*
@ LABEL       >> A
@ LABEL       >> more
@ LABEL       >> powerful
@ LABEL       >> constructor
+ OPERATOR    >> .
& INSTRUCTION >> */
+ OPERATOR    >> */
@ LABEL       >> template
+ OPERATOR    >> <
@ LABEL       >> typename
+ OPERATOR    >> .
+ OPERATOR    >> .
+ OPERATOR    >> .
@ LABEL       >> Args
+ OPERATOR    >> >
@ LABEL       >> List
+ OPERATOR    >> (
@ LABEL       >> Args
+ OPERATOR    >> .
+ OPERATOR    >> .
+ OPERATOR    >> .
@ LABEL       >> parameters
+ OPERATOR    >> )
+ OPERATOR    >> :
@ LABEL       >> start
+ OPERATOR    >> (
+ OPERATOR    >> )
+ OPERATOR    >> ,
@ LABEL       >> end
+ OPERATOR    >> (
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> element_count
+ OPERATOR    >> =
$ NUMBER      >> 0
+ OPERATOR    >> ;
@ LABEL       >> _append
+ OPERATOR    >> (
@ LABEL       >> forward
+ OPERATOR    >> <
@ LABEL       >> Args
+ OPERATOR    >> >
+ OPERATOR    >> (
@ LABEL       >> parameters
+ OPERATOR    >> )
+ OPERATOR    >> .
+ OPERATOR    >> .
+ OPERATOR    >> .
+ OPERATOR    >> )
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Recursive
@ LABEL       >> call
+ OPERATOR    >> .
+ OPERATOR    >> }
@ LABEL       >> List
+ OPERATOR    >> (
@ LABEL       >> std
+ OPERATOR    >> ::
@ LABEL       >> initializer_list
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
@ LABEL       >> list
+ OPERATOR    >> )
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Support
@ LABEL       >> initializer
@ LABEL       >> list
@ LABEL       >> syntax
+ OPERATOR    >> .
@ LABEL       >> List
+ OPERATOR    >> (
* KEYWORD     >> const
@ LABEL       >> List
+ OPERATOR    >> &
@ LABEL       >> other
+ OPERATOR    >> )
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Copy
@ LABEL       >> constructor
@ LABEL       >> for
@ LABEL       >> List
+ OPERATOR    >> .
@ LABEL       >> List
+ OPERATOR    >> (
@ LABEL       >> List
+ OPERATOR    >> &&
@ LABEL       >> other
+ OPERATOR    >> )
+ OPERATOR    >> :
@ LABEL       >> start
+ OPERATOR    >> (
+ OPERATOR    >> )
+ OPERATOR    >> ,
@ LABEL       >> end
+ OPERATOR    >> (
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> element_count
+ OPERATOR    >> =
@ LABEL       >> other
+ OPERATOR    >> .
@ LABEL       >> element_count
+ OPERATOR    >> ;
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> other
+ OPERATOR    >> .
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> other
+ OPERATOR    >> .
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> other
+ OPERATOR    >> .
@ LABEL       >> element_count
+ OPERATOR    >> =
$ NUMBER      >> 0
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Prevent
@ LABEL       >> calling
@ LABEL       >> deconstructor
@ LABEL       >> unexpectedly
+ OPERATOR    >> .
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> nullptr
+ OPERATOR    >> ;
+ OPERATOR    >> }
& INSTRUCTION >> //
@ LABEL       >> Move
@ LABEL       >> constructor
@ LABEL       >> for
@ LABEL       >> List
+ OPERATOR    >> .
& INSTRUCTION >> /*
@ LABEL       >> More
@ LABEL       >> override
@ LABEL       >> operators
@ LABEL       >> for
@ LABEL       >> copy
* KEYWORD     >> and
@ LABEL       >> move
+ OPERATOR    >> .
& INSTRUCTION >> */
+ OPERATOR    >> */
@ LABEL       >> List
+ OPERATOR    >> &
@ LABEL       >> operator
+ OPERATOR    >> =
+ OPERATOR    >> (
* KEYWORD     >> const
@ LABEL       >> List
+ OPERATOR    >> &
@ LABEL       >> other
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> List
+ OPERATOR    >> &
@ LABEL       >> operator
+ OPERATOR    >> =
+ OPERATOR    >> (
@ LABEL       >> List
+ OPERATOR    >> &&
@ LABEL       >> other
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> release
+ OPERATOR    >> (
+ OPERATOR    >> )
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Call
@ LABEL       >> deconstructor
@ LABEL       >> to
@ LABEL       >> prevent
@ LABEL       >> memory
@ LABEL       >> leaking
+ OPERATOR    >> .
@ LABEL       >> element_count
+ OPERATOR    >> =
@ LABEL       >> other
+ OPERATOR    >> .
@ LABEL       >> element_count
+ OPERATOR    >> ;
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> other
+ OPERATOR    >> .
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> other
+ OPERATOR    >> .
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> other
+ OPERATOR    >> .
@ LABEL       >> element_count
+ OPERATOR    >> =
$ NUMBER      >> 0
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Prevent
@ LABEL       >> calling
@ LABEL       >> deconstructor
@ LABEL       >> unexpectedly
+ OPERATOR    >> .
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> nullptr
+ OPERATOR    >> ;
* KEYWORD     >> return
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> ;
+ OPERATOR    >> }
& INSTRUCTION >> /*
@ LABEL       >> Get
@ LABEL       >> iterators
+ OPERATOR    >> .
& INSTRUCTION >> */
+ OPERATOR    >> */
* KEYWORD     >> inline
@ LABEL       >> Iterator
@ LABEL       >> begin
+ OPERATOR    >> (
* KEYWORD     >> void
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> return
@ LABEL       >> start
+ OPERATOR    >> ;
+ OPERATOR    >> }
* KEYWORD     >> inline
@ LABEL       >> Iterator
@ LABEL       >> tail
+ OPERATOR    >> (
* KEYWORD     >> void
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> return
@ LABEL       >> end
+ OPERATOR    >> ;
+ OPERATOR    >> }
& INSTRUCTION >> /*
@ LABEL       >> Functions
@ LABEL       >> to
@ LABEL       >> append
@ LABEL       >> an
@ LABEL       >> element
@ LABEL       >> are
@ LABEL       >> below
+ OPERATOR    >> .
& INSTRUCTION >> */
+ OPERATOR    >> */
@ LABEL       >> List
+ OPERATOR    >> &
@ LABEL       >> append
+ OPERATOR    >> (
@ LABEL       >> Any
+ OPERATOR    >> &
@ LABEL       >> obj
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> List
+ OPERATOR    >> &
@ LABEL       >> append
+ OPERATOR    >> (
@ LABEL       >> Any
+ OPERATOR    >> &&
@ LABEL       >> obj
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> List
+ OPERATOR    >> &
@ LABEL       >> operator
+ OPERATOR    >> <<
+ OPERATOR    >> (
@ LABEL       >> Any
+ OPERATOR    >> &
@ LABEL       >> obj
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> return
@ LABEL       >> append
+ OPERATOR    >> (
@ LABEL       >> obj
+ OPERATOR    >> )
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> List
+ OPERATOR    >> &
@ LABEL       >> operator
+ OPERATOR    >> <<
+ OPERATOR    >> (
@ LABEL       >> Any
+ OPERATOR    >> &&
@ LABEL       >> obj
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> return
@ LABEL       >> append
+ OPERATOR    >> (
@ LABEL       >> forward
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> (
@ LABEL       >> obj
+ OPERATOR    >> )
+ OPERATOR    >> )
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> template
+ OPERATOR    >> <
@ LABEL       >> typename
+ OPERATOR    >> .
+ OPERATOR    >> .
+ OPERATOR    >> .
@ LABEL       >> Args
+ OPERATOR    >> >
* KEYWORD     >> inline
@ LABEL       >> List
+ OPERATOR    >> &
@ LABEL       >> append
+ OPERATOR    >> (
@ LABEL       >> Args
+ OPERATOR    >> .
+ OPERATOR    >> .
+ OPERATOR    >> .
@ LABEL       >> parameters
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> _append
+ OPERATOR    >> (
@ LABEL       >> forward
+ OPERATOR    >> <
@ LABEL       >> Args
+ OPERATOR    >> >
+ OPERATOR    >> (
@ LABEL       >> parameters
+ OPERATOR    >> )
+ OPERATOR    >> .
+ OPERATOR    >> .
+ OPERATOR    >> .
+ OPERATOR    >> )
+ OPERATOR    >> ;
* KEYWORD     >> return
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> ;
+ OPERATOR    >> }
& INSTRUCTION >> /*
@ LABEL       >> Functions
@ LABEL       >> to
@ LABEL       >> get
@ LABEL       >> elements
@ LABEL       >> are
@ LABEL       >> below
+ OPERATOR    >> .
& INSTRUCTION >> */
+ OPERATOR    >> */
@ LABEL       >> Any
@ LABEL       >> operator
+ OPERATOR    >> >>
+ OPERATOR    >> (
@ LABEL       >> Any
+ OPERATOR    >> &
@ LABEL       >> obj
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> return
@ LABEL       >> pop
+ OPERATOR    >> (
$ NUMBER      >> 1
+ OPERATOR    >> )
+ OPERATOR    >> ;
+ OPERATOR    >> }
& INSTRUCTION >> //
@ LABEL       >> Delete
@ LABEL       >> from
@ LABEL       >> the
@ LABEL       >> list
+ OPERATOR    >> .
@ LABEL       >> Any
@ LABEL       >> pop
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> offset
+ OPERATOR    >> )
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Delete
@ LABEL       >> from
@ LABEL       >> the
@ LABEL       >> list
+ OPERATOR    >> .
@ LABEL       >> Any
@ LABEL       >> get
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> offset
+ OPERATOR    >> )
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Do
@ LABEL       >> nothing
+ OPERATOR    >> .
@ LABEL       >> Any
+ OPERATOR    >> &
@ LABEL       >> operator
+ OPERATOR    >> [
+ OPERATOR    >> ]
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> offset
+ OPERATOR    >> )
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Return
@ LABEL       >> reference
+ OPERATOR    >> .
& INSTRUCTION >> /*
@ LABEL       >> Functions
@ LABEL       >> to
@ LABEL       >> insert
@ LABEL       >> elements
@ LABEL       >> are
@ LABEL       >> below
+ OPERATOR    >> .
& INSTRUCTION >> */
+ OPERATOR    >> */
@ LABEL       >> List
+ OPERATOR    >> &
@ LABEL       >> insert
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> where
+ OPERATOR    >> ,
@ LABEL       >> Any
+ OPERATOR    >> &
@ LABEL       >> element
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> List
+ OPERATOR    >> &
@ LABEL       >> insert
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> where
+ OPERATOR    >> ,
@ LABEL       >> Any
+ OPERATOR    >> &&
@ LABEL       >> element
+ OPERATOR    >> )
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Fill
@ LABEL       >> vacancy
@ LABEL       >> automatically
+ OPERATOR    >> .
* KEYWORD     >> inline
@ LABEL       >> size_t
@ LABEL       >> length
+ OPERATOR    >> (
* KEYWORD     >> void
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> return
@ LABEL       >> element_count
+ OPERATOR    >> ;
+ OPERATOR    >> }
* KEYWORD     >> inline
+ OPERATOR    >> ~
@ LABEL       >> List
+ OPERATOR    >> (
* KEYWORD     >> void
+ OPERATOR    >> )
@ LABEL       >> noexcept
+ OPERATOR    >> {
@ LABEL       >> release
+ OPERATOR    >> (
+ OPERATOR    >> )
+ OPERATOR    >> ;
+ OPERATOR    >> }
& INSTRUCTION >> //
@ LABEL       >> Call
@ LABEL       >> deconstructor
+ OPERATOR    >> .
+ OPERATOR    >> }
+ OPERATOR    >> ;
@ LABEL       >> template
+ OPERATOR    >> <
@ LABEL       >> typename
@ LABEL       >> Any
+ OPERATOR    >> >
@ LABEL       >> typename
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> :
+ OPERATOR    >> :
@ LABEL       >> Iterator
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> :
+ OPERATOR    >> :
@ LABEL       >> Iterator
+ OPERATOR    >> ::
@ LABEL       >> operator
+ OPERATOR    >> +
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> offset
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> if
+ OPERATOR    >> (
@ LABEL       >> offset
+ OPERATOR    >> <
$ NUMBER      >> 0
+ OPERATOR    >> )
* KEYWORD     >> return
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> -
+ OPERATOR    >> (
+ OPERATOR    >> -
@ LABEL       >> offset
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> Iterator
@ LABEL       >> iter
+ OPERATOR    >> (
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> for
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> i
+ OPERATOR    >> =
$ NUMBER      >> 0
+ OPERATOR    >> ;
@ LABEL       >> i
+ OPERATOR    >> <
@ LABEL       >> offset
+ OPERATOR    >> ;
@ LABEL       >> i
+ OPERATOR    >> ++
+ OPERATOR    >> )
@ LABEL       >> iter
+ OPERATOR    >> ++
+ OPERATOR    >> ;
* KEYWORD     >> return
@ LABEL       >> iter
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> template
+ OPERATOR    >> <
@ LABEL       >> typename
@ LABEL       >> Any
+ OPERATOR    >> >
@ LABEL       >> typename
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> :
+ OPERATOR    >> :
@ LABEL       >> Iterator
+ OPERATOR    >> &
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> :
+ OPERATOR    >> :
@ LABEL       >> Iterator
+ OPERATOR    >> ::
@ LABEL       >> operator
+ OPERATOR    >> +=
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> offset
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> if
+ OPERATOR    >> (
@ LABEL       >> offset
+ OPERATOR    >> <
$ NUMBER      >> 0
+ OPERATOR    >> )
* KEYWORD     >> return
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> -=
+ OPERATOR    >> (
+ OPERATOR    >> -
@ LABEL       >> offset
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> for
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> i
+ OPERATOR    >> =
$ NUMBER      >> 0
+ OPERATOR    >> ;
@ LABEL       >> i
+ OPERATOR    >> <
@ LABEL       >> offset
+ OPERATOR    >> ;
@ LABEL       >> i
+ OPERATOR    >> ++
+ OPERATOR    >> )
+ OPERATOR    >> (
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> )
+ OPERATOR    >> ++
+ OPERATOR    >> ;
* KEYWORD     >> return
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> template
+ OPERATOR    >> <
@ LABEL       >> typename
@ LABEL       >> Any
+ OPERATOR    >> >
@ LABEL       >> typename
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> :
+ OPERATOR    >> :
@ LABEL       >> Iterator
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> :
+ OPERATOR    >> :
@ LABEL       >> Iterator
+ OPERATOR    >> ::
@ LABEL       >> operator
+ OPERATOR    >> -
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> offset
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> if
+ OPERATOR    >> (
@ LABEL       >> offset
+ OPERATOR    >> <
$ NUMBER      >> 0
+ OPERATOR    >> )
* KEYWORD     >> return
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> +
+ OPERATOR    >> (
+ OPERATOR    >> -
@ LABEL       >> offset
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> Iterator
@ LABEL       >> iter
+ OPERATOR    >> (
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> for
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> i
+ OPERATOR    >> =
$ NUMBER      >> 0
+ OPERATOR    >> ;
@ LABEL       >> i
+ OPERATOR    >> <
@ LABEL       >> offset
+ OPERATOR    >> ;
@ LABEL       >> i
+ OPERATOR    >> ++
+ OPERATOR    >> )
@ LABEL       >> iter
+ OPERATOR    >> --
+ OPERATOR    >> ;
* KEYWORD     >> return
@ LABEL       >> iter
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> template
+ OPERATOR    >> <
@ LABEL       >> typename
@ LABEL       >> Any
+ OPERATOR    >> >
@ LABEL       >> typename
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> :
+ OPERATOR    >> :
@ LABEL       >> Iterator
+ OPERATOR    >> &
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> :
+ OPERATOR    >> :
@ LABEL       >> Iterator
+ OPERATOR    >> ::
@ LABEL       >> operator
+ OPERATOR    >> -=
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> offset
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> if
+ OPERATOR    >> (
@ LABEL       >> offset
+ OPERATOR    >> <
$ NUMBER      >> 0
+ OPERATOR    >> )
* KEYWORD     >> return
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> +=
+ OPERATOR    >> (
+ OPERATOR    >> -
@ LABEL       >> offset
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> for
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> i
+ OPERATOR    >> =
$ NUMBER      >> 0
+ OPERATOR    >> ;
@ LABEL       >> i
+ OPERATOR    >> <
@ LABEL       >> offset
+ OPERATOR    >> ;
@ LABEL       >> i
+ OPERATOR    >> ++
+ OPERATOR    >> )
+ OPERATOR    >> (
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> )
+ OPERATOR    >> --
+ OPERATOR    >> ;
* KEYWORD     >> return
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> template
+ OPERATOR    >> <
@ LABEL       >> typename
@ LABEL       >> Any
+ OPERATOR    >> >
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> :
+ OPERATOR    >> :
@ LABEL       >> List
+ OPERATOR    >> (
@ LABEL       >> std
+ OPERATOR    >> ::
@ LABEL       >> initializer_list
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
@ LABEL       >> list
+ OPERATOR    >> )
+ OPERATOR    >> :
@ LABEL       >> start
+ OPERATOR    >> (
+ OPERATOR    >> )
+ OPERATOR    >> ,
@ LABEL       >> end
+ OPERATOR    >> (
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> element_count
+ OPERATOR    >> =
$ NUMBER      >> 0
+ OPERATOR    >> ;
@ LABEL       >> auto
@ LABEL       >> iterator
+ OPERATOR    >> =
@ LABEL       >> list
+ OPERATOR    >> .
@ LABEL       >> begin
+ OPERATOR    >> (
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> for
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> i
+ OPERATOR    >> =
$ NUMBER      >> 0
+ OPERATOR    >> ;
@ LABEL       >> i
+ OPERATOR    >> <
@ LABEL       >> list
+ OPERATOR    >> .
@ LABEL       >> size
+ OPERATOR    >> (
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> i
+ OPERATOR    >> ++
+ OPERATOR    >> )
@ LABEL       >> append
+ OPERATOR    >> (
+ OPERATOR    >> *
@ LABEL       >> iterator
+ OPERATOR    >> )
+ OPERATOR    >> ,
+ OPERATOR    >> ++
@ LABEL       >> iterator
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> template
+ OPERATOR    >> <
@ LABEL       >> typename
@ LABEL       >> Any
+ OPERATOR    >> >
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> &
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> :
+ OPERATOR    >> :
@ LABEL       >> append
+ OPERATOR    >> (
@ LABEL       >> Any
+ OPERATOR    >> &
@ LABEL       >> obj
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> if
+ OPERATOR    >> (
@ LABEL       >> element_count
+ OPERATOR    >> ==
$ NUMBER      >> 0
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
* KEYWORD     >> new
@ LABEL       >> unit
+ OPERATOR    >> ;
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> object
+ OPERATOR    >> =
@ LABEL       >> obj
+ OPERATOR    >> ;
@ LABEL       >> element_count
+ OPERATOR    >> ++
+ OPERATOR    >> ;
* KEYWORD     >> return
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> unit
+ OPERATOR    >> *
@ LABEL       >> temp
+ OPERATOR    >> =
* KEYWORD     >> new
@ LABEL       >> unit
+ OPERATOR    >> ;
@ LABEL       >> temp
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> temp
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> =
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> temp
+ OPERATOR    >> ;
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> =
@ LABEL       >> temp
+ OPERATOR    >> ;
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> temp
+ OPERATOR    >> ;
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> object
+ OPERATOR    >> =
@ LABEL       >> obj
+ OPERATOR    >> ;
@ LABEL       >> element_count
+ OPERATOR    >> ++
+ OPERATOR    >> ;
* KEYWORD     >> return
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> template
+ OPERATOR    >> <
@ LABEL       >> typename
@ LABEL       >> Any
+ OPERATOR    >> >
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> &
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> :
+ OPERATOR    >> :
@ LABEL       >> append
+ OPERATOR    >> (
@ LABEL       >> Any
+ OPERATOR    >> &&
@ LABEL       >> obj
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> if
+ OPERATOR    >> (
@ LABEL       >> element_count
+ OPERATOR    >> ==
$ NUMBER      >> 0
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
* KEYWORD     >> new
@ LABEL       >> unit
+ OPERATOR    >> ;
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> object
+ OPERATOR    >> =
@ LABEL       >> forward
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> (
@ LABEL       >> obj
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> element_count
+ OPERATOR    >> ++
+ OPERATOR    >> ;
* KEYWORD     >> return
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> unit
+ OPERATOR    >> *
@ LABEL       >> temp
+ OPERATOR    >> =
* KEYWORD     >> new
@ LABEL       >> unit
+ OPERATOR    >> ;
@ LABEL       >> temp
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> temp
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> =
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> temp
+ OPERATOR    >> ;
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> =
@ LABEL       >> temp
+ OPERATOR    >> ;
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> temp
+ OPERATOR    >> ;
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> object
+ OPERATOR    >> =
@ LABEL       >> forward
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> (
@ LABEL       >> obj
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> element_count
+ OPERATOR    >> ++
+ OPERATOR    >> ;
* KEYWORD     >> return
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> template
+ OPERATOR    >> <
@ LABEL       >> typename
@ LABEL       >> Any
+ OPERATOR    >> >
@ LABEL       >> Any
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> :
+ OPERATOR    >> :
@ LABEL       >> get
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> offset
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> if
+ OPERATOR    >> (
@ LABEL       >> element_count
+ OPERATOR    >> ==
$ NUMBER      >> 0
+ OPERATOR    >> )
* KEYWORD     >> return
@ LABEL       >> Any
+ OPERATOR    >> (
+ OPERATOR    >> )
+ OPERATOR    >> ;
& INSTRUCTION >> /*
@ LABEL       >> Correct
@ LABEL       >> offset
+ OPERATOR    >> .
& INSTRUCTION >> */
+ OPERATOR    >> */
* KEYWORD     >> while
+ OPERATOR    >> (
@ LABEL       >> offset
+ OPERATOR    >> <
$ NUMBER      >> 0
+ OPERATOR    >> )
@ LABEL       >> offset
+ OPERATOR    >> +=
@ LABEL       >> element_count
+ OPERATOR    >> ;
* KEYWORD     >> while
+ OPERATOR    >> (
@ LABEL       >> offset
+ OPERATOR    >> >=
@ LABEL       >> element_count
+ OPERATOR    >> )
@ LABEL       >> offset
+ OPERATOR    >> -=
@ LABEL       >> element_count
+ OPERATOR    >> ;
@ LABEL       >> Iterator
@ LABEL       >> iter
+ OPERATOR    >> ;
* KEYWORD     >> if
+ OPERATOR    >> (
@ LABEL       >> offset
+ OPERATOR    >> >=
+ OPERATOR    >> (
@ LABEL       >> element_count
+ OPERATOR    >> >>
$ NUMBER      >> 1
+ OPERATOR    >> )
+ OPERATOR    >> )
& INSTRUCTION >> //
@ LABEL       >> Decrease
@ LABEL       >> the
@ LABEL       >> length
@ LABEL       >> of
@ LABEL       >> searching
@ LABEL       >> path
+ OPERATOR    >> .
+ OPERATOR    >> {
@ LABEL       >> iter
+ OPERATOR    >> =
@ LABEL       >> end
+ OPERATOR    >> ;
@ LABEL       >> iter
+ OPERATOR    >> -=
@ LABEL       >> element_count
+ OPERATOR    >> -
@ LABEL       >> offset
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> else
+ OPERATOR    >> {
@ LABEL       >> iter
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> ;
@ LABEL       >> iter
+ OPERATOR    >> +=
@ LABEL       >> offset
+ OPERATOR    >> ;
+ OPERATOR    >> }
* KEYWORD     >> return
@ LABEL       >> iter
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> object
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> template
+ OPERATOR    >> <
@ LABEL       >> typename
@ LABEL       >> Any
+ OPERATOR    >> >
@ LABEL       >> Any
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> :
+ OPERATOR    >> :
@ LABEL       >> pop
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> offset
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> if
+ OPERATOR    >> (
@ LABEL       >> element_count
+ OPERATOR    >> ==
$ NUMBER      >> 0
+ OPERATOR    >> )
* KEYWORD     >> return
@ LABEL       >> Any
+ OPERATOR    >> (
+ OPERATOR    >> )
+ OPERATOR    >> ;
& INSTRUCTION >> /*
@ LABEL       >> Correct
@ LABEL       >> offset
+ OPERATOR    >> .
& INSTRUCTION >> */
+ OPERATOR    >> */
* KEYWORD     >> while
+ OPERATOR    >> (
@ LABEL       >> offset
+ OPERATOR    >> <
$ NUMBER      >> 0
+ OPERATOR    >> )
@ LABEL       >> offset
+ OPERATOR    >> +=
@ LABEL       >> element_count
+ OPERATOR    >> ;
* KEYWORD     >> while
+ OPERATOR    >> (
@ LABEL       >> offset
+ OPERATOR    >> >=
@ LABEL       >> element_count
+ OPERATOR    >> )
@ LABEL       >> offset
+ OPERATOR    >> -=
@ LABEL       >> element_count
+ OPERATOR    >> ;
* KEYWORD     >> if
+ OPERATOR    >> (
@ LABEL       >> offset
+ OPERATOR    >> ==
$ NUMBER      >> 0
+ OPERATOR    >> )
& INSTRUCTION >> //
@ LABEL       >> Popping
@ LABEL       >> the
@ LABEL       >> first
@ LABEL       >> element
@ LABEL       >> changes
@ LABEL       >> the
@ LABEL       >> start
+ OPERATOR    >> .
+ OPERATOR    >> {
@ LABEL       >> Any
@ LABEL       >> temp
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> object
+ OPERATOR    >> ;
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> ;
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> ;
@ LABEL       >> unit
+ OPERATOR    >> *
@ LABEL       >> tmp
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> start
+ OPERATOR    >> ++
+ OPERATOR    >> ;
* KEYWORD     >> delete
@ LABEL       >> tmp
+ OPERATOR    >> ;
* KEYWORD     >> return
@ LABEL       >> temp
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> Iterator
@ LABEL       >> iter
+ OPERATOR    >> ;
* KEYWORD     >> if
+ OPERATOR    >> (
@ LABEL       >> offset
+ OPERATOR    >> >=
+ OPERATOR    >> (
@ LABEL       >> element_count
+ OPERATOR    >> >>
$ NUMBER      >> 1
+ OPERATOR    >> )
+ OPERATOR    >> )
& INSTRUCTION >> //
@ LABEL       >> Decrease
@ LABEL       >> the
@ LABEL       >> length
@ LABEL       >> of
@ LABEL       >> searching
@ LABEL       >> path
+ OPERATOR    >> .
+ OPERATOR    >> {
@ LABEL       >> iter
+ OPERATOR    >> =
@ LABEL       >> end
+ OPERATOR    >> ;
@ LABEL       >> iter
+ OPERATOR    >> -=
@ LABEL       >> element_count
+ OPERATOR    >> -
@ LABEL       >> offset
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> else
+ OPERATOR    >> {
@ LABEL       >> iter
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> ;
@ LABEL       >> iter
+ OPERATOR    >> +=
@ LABEL       >> offset
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> Any
@ LABEL       >> temp
+ OPERATOR    >> =
@ LABEL       >> iter
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> object
+ OPERATOR    >> ;
@ LABEL       >> iter
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> =
@ LABEL       >> iter
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> ;
@ LABEL       >> iter
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> iter
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> ;
* KEYWORD     >> delete
@ LABEL       >> iter
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
* KEYWORD     >> return
@ LABEL       >> temp
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> template
+ OPERATOR    >> <
@ LABEL       >> typename
@ LABEL       >> Any
+ OPERATOR    >> >
@ LABEL       >> Any
+ OPERATOR    >> &
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> :
+ OPERATOR    >> :
@ LABEL       >> operator
+ OPERATOR    >> [
+ OPERATOR    >> ]
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> offset
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> if
+ OPERATOR    >> (
@ LABEL       >> element_count
+ OPERATOR    >> ==
$ NUMBER      >> 0
+ OPERATOR    >> )
@ LABEL       >> throw
$ NUMBER      >> 0
+ OPERATOR    >> ;
& INSTRUCTION >> /*
@ LABEL       >> Correct
@ LABEL       >> offset
+ OPERATOR    >> .
& INSTRUCTION >> */
+ OPERATOR    >> */
* KEYWORD     >> while
+ OPERATOR    >> (
@ LABEL       >> offset
+ OPERATOR    >> <
$ NUMBER      >> 0
+ OPERATOR    >> )
@ LABEL       >> offset
+ OPERATOR    >> +=
@ LABEL       >> element_count
+ OPERATOR    >> ;
* KEYWORD     >> while
+ OPERATOR    >> (
@ LABEL       >> offset
+ OPERATOR    >> >=
@ LABEL       >> element_count
+ OPERATOR    >> )
@ LABEL       >> offset
+ OPERATOR    >> -=
@ LABEL       >> element_count
+ OPERATOR    >> ;
@ LABEL       >> Iterator
@ LABEL       >> iter
+ OPERATOR    >> ;
* KEYWORD     >> if
+ OPERATOR    >> (
@ LABEL       >> offset
+ OPERATOR    >> >=
+ OPERATOR    >> (
@ LABEL       >> element_count
+ OPERATOR    >> >>
$ NUMBER      >> 1
+ OPERATOR    >> )
+ OPERATOR    >> )
& INSTRUCTION >> //
@ LABEL       >> Decrease
@ LABEL       >> the
@ LABEL       >> length
@ LABEL       >> of
@ LABEL       >> searching
@ LABEL       >> path
+ OPERATOR    >> .
+ OPERATOR    >> {
@ LABEL       >> iter
+ OPERATOR    >> =
@ LABEL       >> end
+ OPERATOR    >> ;
@ LABEL       >> iter
+ OPERATOR    >> -=
@ LABEL       >> element_count
+ OPERATOR    >> -
@ LABEL       >> offset
+ OPERATOR    >> -
$ NUMBER      >> 1
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> else
+ OPERATOR    >> {
@ LABEL       >> iter
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> ;
@ LABEL       >> iter
+ OPERATOR    >> +=
@ LABEL       >> offset
+ OPERATOR    >> ;
+ OPERATOR    >> }
* KEYWORD     >> return
@ LABEL       >> iter
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> object
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> template
+ OPERATOR    >> <
@ LABEL       >> typename
@ LABEL       >> Any
+ OPERATOR    >> >
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> &
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> :
+ OPERATOR    >> :
@ LABEL       >> insert
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> where
+ OPERATOR    >> ,
@ LABEL       >> Any
+ OPERATOR    >> &
@ LABEL       >> element
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> if
+ OPERATOR    >> (
@ LABEL       >> element_count
+ OPERATOR    >> ==
$ NUMBER      >> 0
+ OPERATOR    >> )
& INSTRUCTION >> //
@ LABEL       >> The
@ LABEL       >> first
@ LABEL       >> element
@ LABEL       >> appended
+ OPERATOR    >> .
+ OPERATOR    >> {
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
* KEYWORD     >> new
@ LABEL       >> unit
+ OPERATOR    >> ;
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> object
+ OPERATOR    >> =
@ LABEL       >> element
+ OPERATOR    >> ;
@ LABEL       >> element_count
+ OPERATOR    >> ++
+ OPERATOR    >> ;
* KEYWORD     >> return
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> ;
+ OPERATOR    >> }
& INSTRUCTION >> /*
@ LABEL       >> Correct
@ LABEL       >> offset
+ OPERATOR    >> .
& INSTRUCTION >> */
+ OPERATOR    >> */
* KEYWORD     >> while
+ OPERATOR    >> (
@ LABEL       >> where
+ OPERATOR    >> <
$ NUMBER      >> 0
+ OPERATOR    >> )
@ LABEL       >> where
+ OPERATOR    >> +=
@ LABEL       >> element_count
+ OPERATOR    >> ;
* KEYWORD     >> while
+ OPERATOR    >> (
@ LABEL       >> where
+ OPERATOR    >> >=
@ LABEL       >> element_count
+ OPERATOR    >> )
@ LABEL       >> where
+ OPERATOR    >> -=
@ LABEL       >> element_count
+ OPERATOR    >> ;
@ LABEL       >> Iterator
@ LABEL       >> iter
+ OPERATOR    >> ;
* KEYWORD     >> if
+ OPERATOR    >> (
@ LABEL       >> where
+ OPERATOR    >> >=
+ OPERATOR    >> (
@ LABEL       >> element_count
+ OPERATOR    >> >>
$ NUMBER      >> 1
+ OPERATOR    >> )
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> iter
+ OPERATOR    >> =
@ LABEL       >> end
+ OPERATOR    >> ;
@ LABEL       >> iter
+ OPERATOR    >> -=
@ LABEL       >> element_count
+ OPERATOR    >> -
@ LABEL       >> where
+ OPERATOR    >> -
$ NUMBER      >> 1
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> else
+ OPERATOR    >> {
@ LABEL       >> iter
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> ;
@ LABEL       >> iter
+ OPERATOR    >> +=
@ LABEL       >> where
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> unit
+ OPERATOR    >> *
@ LABEL       >> temp
+ OPERATOR    >> =
* KEYWORD     >> new
@ LABEL       >> unit
+ OPERATOR    >> ;
@ LABEL       >> temp
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> =
@ LABEL       >> iter
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> temp
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> iter
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> ;
@ LABEL       >> iter
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> =
@ LABEL       >> temp
+ OPERATOR    >> ;
@ LABEL       >> iter
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> temp
+ OPERATOR    >> ;
@ LABEL       >> temp
+ OPERATOR    >> ->
@ LABEL       >> object
+ OPERATOR    >> =
@ LABEL       >> element
+ OPERATOR    >> ;
@ LABEL       >> element_count
+ OPERATOR    >> ++
+ OPERATOR    >> ;
* KEYWORD     >> return
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> template
+ OPERATOR    >> <
@ LABEL       >> typename
@ LABEL       >> Any
+ OPERATOR    >> >
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> &
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> :
+ OPERATOR    >> :
@ LABEL       >> insert
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> where
+ OPERATOR    >> ,
@ LABEL       >> Any
+ OPERATOR    >> &&
@ LABEL       >> element
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> if
+ OPERATOR    >> (
@ LABEL       >> element_count
+ OPERATOR    >> ==
$ NUMBER      >> 0
+ OPERATOR    >> )
& INSTRUCTION >> //
@ LABEL       >> The
@ LABEL       >> first
@ LABEL       >> element
@ LABEL       >> appended
+ OPERATOR    >> .
+ OPERATOR    >> {
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
* KEYWORD     >> new
@ LABEL       >> unit
+ OPERATOR    >> ;
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> object
+ OPERATOR    >> =
@ LABEL       >> forward
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> (
@ LABEL       >> element
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> element_count
+ OPERATOR    >> ++
+ OPERATOR    >> ;
* KEYWORD     >> return
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> ;
+ OPERATOR    >> }
& INSTRUCTION >> /*
@ LABEL       >> Correct
@ LABEL       >> offset
+ OPERATOR    >> .
& INSTRUCTION >> */
+ OPERATOR    >> */
* KEYWORD     >> while
+ OPERATOR    >> (
@ LABEL       >> where
+ OPERATOR    >> <
$ NUMBER      >> 0
+ OPERATOR    >> )
@ LABEL       >> where
+ OPERATOR    >> +=
@ LABEL       >> element_count
+ OPERATOR    >> ;
* KEYWORD     >> while
+ OPERATOR    >> (
@ LABEL       >> where
+ OPERATOR    >> >=
@ LABEL       >> element_count
+ OPERATOR    >> )
@ LABEL       >> where
+ OPERATOR    >> -=
@ LABEL       >> element_count
+ OPERATOR    >> ;
@ LABEL       >> Iterator
@ LABEL       >> iter
+ OPERATOR    >> ;
* KEYWORD     >> if
+ OPERATOR    >> (
@ LABEL       >> where
+ OPERATOR    >> >=
+ OPERATOR    >> (
@ LABEL       >> element_count
+ OPERATOR    >> >>
$ NUMBER      >> 1
+ OPERATOR    >> )
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> iter
+ OPERATOR    >> =
@ LABEL       >> end
+ OPERATOR    >> ;
@ LABEL       >> iter
+ OPERATOR    >> -=
@ LABEL       >> element_count
+ OPERATOR    >> -
@ LABEL       >> where
+ OPERATOR    >> -
$ NUMBER      >> 1
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> else
+ OPERATOR    >> {
@ LABEL       >> iter
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> ;
@ LABEL       >> iter
+ OPERATOR    >> +=
@ LABEL       >> where
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> unit
+ OPERATOR    >> *
@ LABEL       >> temp
+ OPERATOR    >> =
* KEYWORD     >> new
@ LABEL       >> unit
+ OPERATOR    >> ;
@ LABEL       >> temp
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> =
@ LABEL       >> iter
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> temp
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> iter
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> ;
@ LABEL       >> iter
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> =
@ LABEL       >> temp
+ OPERATOR    >> ;
@ LABEL       >> iter
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> temp
+ OPERATOR    >> ;
@ LABEL       >> temp
+ OPERATOR    >> ->
@ LABEL       >> object
+ OPERATOR    >> =
@ LABEL       >> forward
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> (
@ LABEL       >> element
+ OPERATOR    >> )
+ OPERATOR    >> ;
@ LABEL       >> element_count
+ OPERATOR    >> ++
+ OPERATOR    >> ;
* KEYWORD     >> return
+ OPERATOR    >> *
@ LABEL       >> this
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> template
+ OPERATOR    >> <
@ LABEL       >> typename
@ LABEL       >> Any
+ OPERATOR    >> >
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> :
+ OPERATOR    >> :
@ LABEL       >> List
+ OPERATOR    >> (
* KEYWORD     >> const
@ LABEL       >> List
+ OPERATOR    >> &
@ LABEL       >> other
+ OPERATOR    >> )
+ OPERATOR    >> :
@ LABEL       >> start
+ OPERATOR    >> (
+ OPERATOR    >> )
+ OPERATOR    >> ,
@ LABEL       >> end
+ OPERATOR    >> (
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> element_count
+ OPERATOR    >> =
@ LABEL       >> other
+ OPERATOR    >> .
@ LABEL       >> element_count
+ OPERATOR    >> ;
@ LABEL       >> Iterator
@ LABEL       >> iter
+ OPERATOR    >> =
@ LABEL       >> other
+ OPERATOR    >> .
@ LABEL       >> start
+ OPERATOR    >> ;
@ LABEL       >> unit
+ OPERATOR    >> *
@ LABEL       >> here
+ OPERATOR    >> ,
+ OPERATOR    >> *
@ LABEL       >> temp
+ OPERATOR    >> ;
* KEYWORD     >> if
+ OPERATOR    >> (
@ LABEL       >> element_count
+ OPERATOR    >> )
+ OPERATOR    >> {
& INSTRUCTION >> /*
@ LABEL       >> Tackle
@ LABEL       >> the
@ LABEL       >> first
@ LABEL       >> element
@ LABEL       >> separately
+ OPERATOR    >> .
& INSTRUCTION >> */
+ OPERATOR    >> */
@ LABEL       >> here
+ OPERATOR    >> =
* KEYWORD     >> new
@ LABEL       >> unit
+ OPERATOR    >> ;
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> =
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> object
+ OPERATOR    >> =
+ OPERATOR    >> *
@ LABEL       >> iter
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Call
@ LABEL       >> copy
@ LABEL       >> function
+ OPERATOR    >> .
@ LABEL       >> for
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> i
+ OPERATOR    >> =
$ NUMBER      >> 0
+ OPERATOR    >> ;
@ LABEL       >> i
+ OPERATOR    >> <
@ LABEL       >> element_count
+ OPERATOR    >> -
$ NUMBER      >> 1
+ OPERATOR    >> ;
@ LABEL       >> i
+ OPERATOR    >> ++
+ OPERATOR    >> )
+ OPERATOR    >> {
& INSTRUCTION >> /*
@ LABEL       >> Allocate
* KEYWORD     >> new
@ LABEL       >> memory
* KEYWORD     >> and
@ LABEL       >> append
@ LABEL       >> it
@ LABEL       >> to
@ LABEL       >> the
@ LABEL       >> tail
+ OPERATOR    >> .
& INSTRUCTION >> */
+ OPERATOR    >> */
@ LABEL       >> temp
+ OPERATOR    >> =
* KEYWORD     >> new
@ LABEL       >> unit
+ OPERATOR    >> ;
@ LABEL       >> temp
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> =
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> temp
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
& INSTRUCTION >> /*
@ LABEL       >> Move
@ LABEL       >> pointer
+ OPERATOR    >> .
& INSTRUCTION >> */
+ OPERATOR    >> */
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> temp
+ OPERATOR    >> ;
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> temp
+ OPERATOR    >> ;
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> temp
+ OPERATOR    >> ;
@ LABEL       >> temp
+ OPERATOR    >> ->
@ LABEL       >> object
+ OPERATOR    >> =
+ OPERATOR    >> *
@ LABEL       >> iter
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Call
@ LABEL       >> copy
@ LABEL       >> function
+ OPERATOR    >> .
@ LABEL       >> iter
+ OPERATOR    >> ++
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Deal
@ LABEL       >> with
@ LABEL       >> next
@ LABEL       >> element
+ OPERATOR    >> .
+ OPERATOR    >> }
+ OPERATOR    >> }
+ OPERATOR    >> }
@ LABEL       >> template
+ OPERATOR    >> <
@ LABEL       >> typename
@ LABEL       >> Any
+ OPERATOR    >> >
* KEYWORD     >> void
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> :
+ OPERATOR    >> :
@ LABEL       >> release
+ OPERATOR    >> (
* KEYWORD     >> void
+ OPERATOR    >> )
+ OPERATOR    >> {
* KEYWORD     >> if
+ OPERATOR    >> (
@ LABEL       >> element_count
+ OPERATOR    >> ==
$ NUMBER      >> 0
+ OPERATOR    >> )
* KEYWORD     >> return
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Prevent
@ LABEL       >> program
@ LABEL       >> from
@ LABEL       >> segment
@ LABEL       >> fault
+ OPERATOR    >> .
@ LABEL       >> unit
+ OPERATOR    >> *
@ LABEL       >> temp
+ OPERATOR    >> ;
@ LABEL       >> Iterator
@ LABEL       >> iter
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> ;
@ LABEL       >> for
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> i
+ OPERATOR    >> =
$ NUMBER      >> 0
+ OPERATOR    >> ;
@ LABEL       >> i
+ OPERATOR    >> <
@ LABEL       >> element_count
+ OPERATOR    >> -
$ NUMBER      >> 1
+ OPERATOR    >> ;
@ LABEL       >> i
+ OPERATOR    >> ++
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> temp
+ OPERATOR    >> =
@ LABEL       >> iter
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> iter
+ OPERATOR    >> ++
+ OPERATOR    >> ;
* KEYWORD     >> delete
@ LABEL       >> temp
+ OPERATOR    >> ;
+ OPERATOR    >> }
* KEYWORD     >> delete
@ LABEL       >> iter
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
+ OPERATOR    >> }
@ LABEL       >> template
+ OPERATOR    >> <
@ LABEL       >> typename
@ LABEL       >> Any
+ OPERATOR    >> >
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> &
@ LABEL       >> List
+ OPERATOR    >> <
@ LABEL       >> Any
+ OPERATOR    >> >
+ OPERATOR    >> :
+ OPERATOR    >> :
@ LABEL       >> operator
+ OPERATOR    >> =
+ OPERATOR    >> (
* KEYWORD     >> const
@ LABEL       >> List
+ OPERATOR    >> &
@ LABEL       >> other
+ OPERATOR    >> )
+ OPERATOR    >> {
@ LABEL       >> release
+ OPERATOR    >> (
+ OPERATOR    >> )
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Call
@ LABEL       >> deconstructor
@ LABEL       >> to
@ LABEL       >> prevent
@ LABEL       >> memory
@ LABEL       >> leaking
+ OPERATOR    >> .
@ LABEL       >> element_count
+ OPERATOR    >> =
@ LABEL       >> other
+ OPERATOR    >> .
@ LABEL       >> element_count
+ OPERATOR    >> ;
@ LABEL       >> Iterator
@ LABEL       >> iter
+ OPERATOR    >> =
@ LABEL       >> other
+ OPERATOR    >> .
@ LABEL       >> start
+ OPERATOR    >> ;
@ LABEL       >> unit
+ OPERATOR    >> *
@ LABEL       >> here
+ OPERATOR    >> ,
+ OPERATOR    >> *
@ LABEL       >> temp
+ OPERATOR    >> ;
* KEYWORD     >> if
+ OPERATOR    >> (
@ LABEL       >> element_count
+ OPERATOR    >> )
+ OPERATOR    >> {
& INSTRUCTION >> /*
@ LABEL       >> Tackle
@ LABEL       >> the
@ LABEL       >> first
@ LABEL       >> element
@ LABEL       >> separately
+ OPERATOR    >> .
& INSTRUCTION >> */
+ OPERATOR    >> */
@ LABEL       >> here
+ OPERATOR    >> =
* KEYWORD     >> new
@ LABEL       >> unit
+ OPERATOR    >> ;
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> =
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> object
+ OPERATOR    >> =
+ OPERATOR    >> *
@ LABEL       >> iter
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Call
@ LABEL       >> copy
@ LABEL       >> function
+ OPERATOR    >> .
@ LABEL       >> for
+ OPERATOR    >> (
* KEYWORD     >> int
@ LABEL       >> i
+ OPERATOR    >> =
$ NUMBER      >> 0
+ OPERATOR    >> ;
@ LABEL       >> i
+ OPERATOR    >> <
@ LABEL       >> element_count
+ OPERATOR    >> -
$ NUMBER      >> 1
+ OPERATOR    >> ;
@ LABEL       >> i
+ OPERATOR    >> ++
+ OPERATOR    >> )
+ OPERATOR    >> {
& INSTRUCTION >> /*
@ LABEL       >> Allocate
* KEYWORD     >> new
@ LABEL       >> memory
* KEYWORD     >> and
@ LABEL       >> append
@ LABEL       >> it
@ LABEL       >> to
@ LABEL       >> the
@ LABEL       >> tail
+ OPERATOR    >> .
& INSTRUCTION >> */
+ OPERATOR    >> */
@ LABEL       >> temp
+ OPERATOR    >> =
* KEYWORD     >> new
@ LABEL       >> unit
+ OPERATOR    >> ;
@ LABEL       >> temp
+ OPERATOR    >> ->
@ LABEL       >> before
+ OPERATOR    >> =
@ LABEL       >> here
+ OPERATOR    >> ;
@ LABEL       >> temp
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> start
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> ;
& INSTRUCTION >> /*
@ LABEL       >> Move
@ LABEL       >> pointer
+ OPERATOR    >> .
& INSTRUCTION >> */
+ OPERATOR    >> */
@ LABEL       >> here
+ OPERATOR    >> ->
@ LABEL       >> next
+ OPERATOR    >> =
@ LABEL       >> temp
+ OPERATOR    >> ;
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> temp
+ OPERATOR    >> ;
@ LABEL       >> end
+ OPERATOR    >> .
@ LABEL       >> here
+ OPERATOR    >> =
@ LABEL       >> temp
+ OPERATOR    >> ;
@ LABEL       >> temp
+ OPERATOR    >> ->
@ LABEL       >> object
+ OPERATOR    >> =
+ OPERATOR    >> *
@ LABEL       >> iter
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Call
@ LABEL       >> copy
@ LABEL       >> function
+ OPERATOR    >> .
@ LABEL       >> iter
+ OPERATOR    >> ++
+ OPERATOR    >> ;
& INSTRUCTION >> //
@ LABEL       >> Deal
@ LABEL       >> with
@ LABEL       >> next
@ LABEL       >> element
+ OPERATOR    >> .
+ OPERATOR    >> }
+ OPERATOR    >> }
+ OPERATOR    >> }
+ OPERATOR    >> #
@ LABEL       >> endif
